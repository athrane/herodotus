# Copilot Custom Instructions

## Project Overview## Testing
- **Framework**: Use Jest with `describe`, `it`, `expect`, and `beforeEach`.
- **File Location & Naming**:
  - All tests are in the `test/` directory, mirroring the `src/` directory structure.
  - Test files must end with `.test.ts` or `.test.js`. Use `.integration.test.js` for integration tests.
- **Test Types**:
  - **Unit Tests**: Test each method in a class, isolating it with mocks.
  - **Integration Tests**: Test the interaction between multiple classes without mocks.
- When adding new features, provide corresponding tests if relevant.
- Follow the repository's testing framework and naming conventions.
- Create unit tests using mocks
- Create unit test for each method in a class
- Create integration tests without mocks, but with usage of classes included in the project
- **Verification**: Before completing a task, run `npm run test` and `npm run lint` to ensure all checks pass.

## Documentationechnologies
- **Project**: Herodotus, a procedural world-building and history generation tool.
- **Language**: TypeScript (ES2020, ESNext modules) with strict mode enabled.
- **Primary Architecture**: Entity-Component-System (ECS).
- **Testing Framework**: Jest, using ts-jest for TypeScript and babel-jest for JavaScript.
- **Key Tooling**:
  - Linting: ESLint (`npm run lint`)
  - Type Checking: TypeScript Compiler (`npm run typecheck`)
  - Testing: Jest (`npm run test`)
  - Bundling: esbuild
  - Development Runner: tsx

## Architecture & Design Patterns
- **Entity-Component-System (ECS)**: This is the core pattern.
  - **Components**: Data-only classes extending the base Component. They must not contain logic.
  - **Systems**: Logic-only classes extending the base System. They operate on entities possessing specific components.
    - **System Implementation Preference**: When implementing systems, prefer overriding the `processEntity` method over the `update` method. The `processEntity` method handles individual entity processing and is called automatically by the base `update` method for each relevant entity. Only override `update` for complex scenarios requiring custom entity iteration logic.
  - **Entities**: Simple identifiers managed by the EntityManager.
- **Builder Pattern**: The SimulationDirector and SimulationBuilder are used to construct the simulation. New features should be integrated through this pattern.
- **Factory Method**: All classes must provide a static create() factory method for instantiation.

## General Guidance
- Follow established coding conventions and style guides used in this repository.
- Prefer clear, readable, and maintainable code over clever or overly compact solutions.
- Include comments for complex logic or non-obvious decisions.
- For configuration files, match the format and structure already used (YAML, JSON, etc).
- Always create a static factory function when implementing a class

## Coding Conventions
### File Structure:
- All source code is in the `src/` directory.
- Organize files by domain (`ecs/`, `geography/`, `simulation/`, etc.).
- Place each class in its own file, named after the class in PascalCase (e.g., `WorldGenerator.ts`).

### Syntax & Style:
- Use ES module syntax (`import`/`export`) for all new files and refactors.
- Adhere to a class-based, object-oriented style.
- Use static class properties for constants and document them with JSDoc.
- When creating new classes, always provide a static `create` factory method in addition to the constructor.
- For constants (such as configuration values or default numbers), use `static` class properties and document them with JSDoc.
- Prefer descriptive and explicit naming for all classes, methods, and variables.

### Comments & Documentation:
- Add JSDoc comments to all classes and public methods to explain their purpose.
- For complex logic, add inline comments explaining the why.

## Language/Framework Preferences
- Use the primary language(s) and frameworks found in this repository.
- Prefer built-in or standard library functionality when possible.
- Use dependency versions compatible with the current codebase.

## Testing
- When adding new features, provide corresponding tests if relevant.
- Follow the repositoryâ€™s testing framework and naming conventions.
- Create unit tests using mocks
- Create unit test for each method in a class
- Create integration tests without mocks, but with usage of classes included in the project
- Prior to completing a task, verify the ESLint pre-commit check doesn't fails.

## Documentation 
- When adding or modifying a class, update the Class Documentation section in the main README.md file.
- Documentation about classes should be documented in the Class Documentation section.
- Documentation about classes should include a description of their responsibilities and their role in any design patterns.

## ESLint pre-commit errors
- Prior to completing a task, ensure there are no ESLint pre-commit errors. If there are errors, then fix them.
- Prior to completing a task, verify the ESLint pre-commit check doesn't fail.

## Commits & Pull Requests
- Before committing, ensure all code passes pre-commit hooks (ESLint).
- Reference related issues in Pull Request descriptions.
- Reference related issues or discussions in your PR descriptions.
- Ensure all CI checks pass before requesting a merge.
- Ensure all code passes CI checks and linting before merging.

## Additional Notes
- If unsure, ask for clarification or review from the repository maintainers.
- Avoid introducing breaking changes unless explicitly requested.

## Project-Specific Guidance
- For utility functions, use the `TypeUtils` or similar utility modules when type checking or validation is needed.
- When adding new features to the simulation, ensure they are integrated via the `SimulationDirector` and `SimulationBuilder` patterns.
- When adding new entity or component types, ensure they are registered and accessible through the `EntityManager` and `SystemManager`.

# End of instructions